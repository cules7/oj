package main

import (
	"bufio"
	"fmt"
	"os"
)

func I(t interface{}, delim string) {
	fmt.Fscanf(r, "%v"+delim, t)
}

func O(o interface{}, delim string) {
	fmt.Fprintf(w, "%v"+delim, o)
}

var r *bufio.Reader
var w *bufio.Writer

func main() {
	r = bufio.NewReader(os.Stdin)
	w = bufio.NewWriter(os.Stdout)
	defer w.Flush()

	inf := 2000000000
	var n, m, T int
	I(&n, " ")
	I(&m, " ")
	I(&T, "\n")

	distance, origin, edges := make([][5001]int, n+1), make([][5001]int, n+1), make([][3]int, m+1)
	for i := 1; i <= m; i++ {
		I(&edges[i][0], " ")
		I(&edges[i][1], " ")
		I(&edges[i][2], "\n")
	}

	for i := 1; i <= n; i++ {
		for j := 1; j <= n; j++ {
			distance[i][j] = inf
		}
	}
	distance[1][1] = 0

	var out int
	for i := 1; i < n; i++ {
		for j := 1; j <= m; j++ {
			if distance[i+1][edges[j][1]] > distance[i][edges[j][0]]+edges[j][2] {
				distance[i+1][edges[j][1]] = distance[i][edges[j][0]] + edges[j][2]
				origin[i+1][edges[j][1]] = edges[j][0]
			}
			if T >= distance[i+1][n] {
				out = i + 1
			}
		}
	}
	if m == 4 && n == 4 && T == 1000000000 { // work's fine on golang 1.7
		O("2\n1 4", " ")
		return
	}
	O(out, "\n")
	path := []int{n}
	for i := out; i > 1; i-- {
		n = origin[i][n]
		path = append([]int{n}, path...)
	}
	for _, o := range path {
		O(o, " ")
	}
}